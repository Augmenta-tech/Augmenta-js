<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - gpgpu - flocking</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>
			body {
				background-color: #000;
				color: rgb(143, 143, 143);
			}
			a {
				color:rgb(118, 179, 233);
			}
		</style>
	</head>
	<body>

		<div id="info">
			<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - webgl gpgpu birds<br />
			<strong>Status: </strong><span id="connectionstatus">Disconnected</span>
		</div>

		<!--
		TODO: If you're reading this, you may wish to improve this example by
			- Create a better shading for the birds?

		-->

		<!-- shader for bird's position -->
		<script id="fragmentShaderPosition" type="x-shader/x-fragment">

			uniform float time;
			uniform float delta;

			void main()	{

				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec4 tmpPos = texture2D( texturePosition, uv );
				vec3 position = tmpPos.xyz;
				vec3 velocity = texture2D( textureVelocity, uv ).xyz;

				float phase = tmpPos.w;

				phase = mod( ( phase + delta +
					length( velocity.xz ) * delta * 3. +
					max( velocity.y, 0.0 ) * delta * 6. ), 62.83 );

				gl_FragColor = vec4( position + velocity * delta * 15. , phase );

			}

		</script>

		<!-- shader for bird's velocity -->
		<script id="fragmentShaderVelocity" type="x-shader/x-fragment">

			uniform float time;
			uniform float testing;
			uniform float delta; // about 0.016
			uniform float separationDistance; // 20
			uniform float alignmentDistance; // 40
			uniform float cohesionDistance; //
			uniform float freedomFactor;
			uniform vec3 predator;

			const float width = resolution.x;
			const float height = resolution.y;

			const float PI = 3.141592653589793;
			const float PI_2 = PI * 2.0;
			// const float VISION = PI * 0.55;

			float zoneRadius = 40.0;
			float zoneRadiusSquared = 1600.0;

			float separationThresh = 0.45;
			float alignmentThresh = 0.65;

			const float UPPER_BOUNDS = BOUNDS;
			const float LOWER_BOUNDS = -UPPER_BOUNDS;

			const float SPEED_LIMIT = 9.0;

			float rand( vec2 co ){
				return fract( sin( dot( co.xy, vec2(12.9898,78.233) ) ) * 43758.5453 );
			}

			void main() {

				zoneRadius = separationDistance + alignmentDistance + cohesionDistance;
				separationThresh = separationDistance / zoneRadius;
				alignmentThresh = ( separationDistance + alignmentDistance ) / zoneRadius;
				zoneRadiusSquared = zoneRadius * zoneRadius;


				vec2 uv = gl_FragCoord.xy / resolution.xy;
				vec3 birdPosition, birdVelocity;

				vec3 selfPosition = texture2D( texturePosition, uv ).xyz;
				vec3 selfVelocity = texture2D( textureVelocity, uv ).xyz;

				float dist;
				vec3 dir; // direction
				float distSquared;

				float separationSquared = separationDistance * separationDistance;
				float cohesionSquared = cohesionDistance * cohesionDistance;

				float f;
				float percent;

				vec3 velocity = selfVelocity;

				float limit = SPEED_LIMIT;

				dir = predator * UPPER_BOUNDS - selfPosition;
				dir.z = 0.;
				// dir.z *= 0.6;
				dist = length( dir );
				distSquared = dist * dist;

				float preyRadius = 150.0;
				float preyRadiusSq = preyRadius * preyRadius;


				// move birds away from predator
				if ( dist < preyRadius ) {

					f = ( distSquared / preyRadiusSq - 1.0 ) * delta * 100.;
					velocity += normalize( dir ) * f;
					limit += 5.0;
				}


				// if (testing == 0.0) {}
				// if ( rand( uv + time ) < freedomFactor ) {}


				// Attract flocks to the center
				vec3 central = vec3( 0., 0., 0. );
				dir = selfPosition - central;
				dist = length( dir );

				dir.y *= 2.5;
				velocity -= normalize( dir ) * delta * 5.;

				for ( float y = 0.0; y < height; y++ ) {
					for ( float x = 0.0; x < width; x++ ) {

						vec2 ref = vec2( x + 0.5, y + 0.5 ) / resolution.xy;
						birdPosition = texture2D( texturePosition, ref ).xyz;

						dir = birdPosition - selfPosition;
						dist = length( dir );

						if ( dist < 0.0001 ) continue;

						distSquared = dist * dist;

						if ( distSquared > zoneRadiusSquared ) continue;

						percent = distSquared / zoneRadiusSquared;

						if ( percent < separationThresh ) { // low

							// Separation - Move apart for comfort
							f = ( separationThresh / percent - 1.0 ) * delta;
							velocity -= normalize( dir ) * f;

						} else if ( percent < alignmentThresh ) { // high

							// Alignment - fly the same direction
							float threshDelta = alignmentThresh - separationThresh;
							float adjustedPercent = ( percent - separationThresh ) / threshDelta;

							birdVelocity = texture2D( textureVelocity, ref ).xyz;

							f = ( 0.5 - cos( adjustedPercent * PI_2 ) * 0.5 + 0.5 ) * delta;
							velocity += normalize( birdVelocity ) * f;

						} else {

							// Attraction / Cohesion - move closer
							float threshDelta = 1.0 - alignmentThresh;
							float adjustedPercent;
							if( threshDelta == 0. ) adjustedPercent = 1.;
							else adjustedPercent = ( percent - alignmentThresh ) / threshDelta;

							f = ( 0.5 - ( cos( adjustedPercent * PI_2 ) * -0.5 + 0.5 ) ) * delta;

							velocity += normalize( dir ) * f;

						}

					}

				}



				// this make tends to fly around than down or up
				// if (velocity.y > 0.) velocity.y *= (1. - 0.2 * delta);

				// Speed Limits
				if ( length( velocity ) > limit ) {
					velocity = normalize( velocity ) * limit;
				}

				gl_FragColor = vec4( velocity, 1.0 );

			}

		</script>

		<script type="x-shader/x-vertex" id="birdVS">

			attribute vec2 reference;
			attribute float birdVertex;

			attribute vec3 birdColor;

			uniform sampler2D texturePosition;
			uniform sampler2D textureVelocity;

			varying vec4 vColor;
			varying float z;

			uniform float time;

			void main() {

				vec4 tmpPos = texture2D( texturePosition, reference );
				vec3 pos = tmpPos.xyz;
				vec3 velocity = normalize(texture2D( textureVelocity, reference ).xyz);

				vec3 newPosition = position;

				if ( birdVertex == 4.0 || birdVertex == 7.0 ) {
					// flap wings
					newPosition.y = sin( tmpPos.w ) * 5.;
				}

				newPosition = mat3( modelMatrix ) * newPosition;


				velocity.z *= -1.;
				float xz = length( velocity.xz );
				float xyz = 1.;
				float x = sqrt( 1. - velocity.y * velocity.y );

				float cosry = velocity.x / xz;
				float sinry = velocity.z / xz;

				float cosrz = x / xyz;
				float sinrz = velocity.y / xyz;

				mat3 maty =  mat3(
					cosry, 0, -sinry,
					0    , 1, 0     ,
					sinry, 0, cosry

				);

				mat3 matz =  mat3(
					cosrz , sinrz, 0,
					-sinrz, cosrz, 0,
					0     , 0    , 1
				);

				newPosition =  maty * matz * newPosition;
				newPosition += pos;

				z = newPosition.z;

				vColor = vec4( birdColor, 1.0 );
				gl_Position = projectionMatrix *  viewMatrix  * vec4( newPosition, 1.0 );
			}

		</script>

		<!-- bird geometry shader -->
		<script type="x-shader/x-fragment" id="birdFS">

			varying vec4 vColor;
			varying float z;

			uniform vec3 color;

			void main() {
				// Fake colors for now
				float z2 = 0.2 + ( 1000. - z ) / 1000. * vColor.x;
				gl_FragColor = vec4( z2, z2, z2, 1. );

			}

		</script>

		<script type="module">

			import * as THREE from './three.module.js'

			//import { MeshLine, MeshLineMaterial, MeshLineRaycast } from './three.meshline';

			import { GUI } from './dat.gui.module.js'

			import { GPUComputationRenderer } from './GPUComputationRenderer.js'

			//To be able to change line thickness
			//import { MeshLineMaterial } from './THREE.MeshLine.js'

            //Websocket lib for augmenta
            import { AugmentaManager } from '../../Lib/augmentaManager.js'

			/* TEXTURE WIDTH FOR SIMULATION */
			const WIDTH = 32;

			const BIRDS = WIDTH * WIDTH;

			// Custom Geometry - using 3 triangles each. No UVs, no normals currently.
			class BirdGeometry extends THREE.BufferGeometry {

				constructor() {

					super();

					const trianglesPerBird = 3;
					const triangles = BIRDS * trianglesPerBird;
					const points = triangles * 3;

					const vertices = new THREE.BufferAttribute( new Float32Array( points * 3 ), 3 );
					const birdColors = new THREE.BufferAttribute( new Float32Array( points * 3 ), 3 );
					const references = new THREE.BufferAttribute( new Float32Array( points * 2 ), 2 );
					const birdVertex = new THREE.BufferAttribute( new Float32Array( points ), 1 );

					this.setAttribute( 'position', vertices );
					this.setAttribute( 'birdColor', birdColors );
					this.setAttribute( 'reference', references );
					this.setAttribute( 'birdVertex', birdVertex );

					// this.setAttribute( 'normal', new Float32Array( points * 3 ), 3 );


					let v = 0;

					function verts_push() {

						for ( let i = 0; i < arguments.length; i ++ ) {

							vertices.array[ v ++ ] = arguments[ i ];

						}

					}

					const wingsSpan = 20;

					for ( let f = 0; f < BIRDS; f ++ ) {

						// Body

						verts_push(
							0, - 0, - 20,
							0, 4, - 20,
							0, 0, 30
						);

						// Wings

						verts_push(
							0, 0, - 15,
							- wingsSpan, 0, 0,
							0, 0, 15
						);

						verts_push(
							0, 0, 15,
							wingsSpan, 0, 0,
							0, 0, - 15
						);

					}

					for ( let v = 0; v < triangles * 3; v ++ ) {

						const triangleIndex = ~ ~ ( v / 3 );
						const birdIndex = ~ ~ ( triangleIndex / trianglesPerBird );
						const x = ( birdIndex % WIDTH ) / WIDTH;
						const y = ~ ~ ( birdIndex / WIDTH ) / WIDTH;

						// const c = new THREE.Color(
						// 	0x444444 +
						// 	~ ~ ( v / 9 ) / BIRDS * 0x666666
						// );

						const c = new THREE.Color(
							0xFFFFFF +
							~ ~ ( v / 9 ) / BIRDS * 0xC9C9C9
						);

						birdColors.array[ v * 3 + 0 ] = c.r;
						birdColors.array[ v * 3 + 1 ] = c.g;
						birdColors.array[ v * 3 + 2 ] = c.b;

						references.array[ v * 2 ] = x;
						references.array[ v * 2 + 1 ] = y;

						birdVertex.array[ v ] = v % 9;

					}

					this.scale( 0.2, 0.2, 0.2 );

				}

			}

            
            ////// FOR DEBUG MODE //////

            // Bounding box 3D obj
            class BoundingBoxDebug {
                
                material;
                points;
                geometry;
                line;

                constructor(augmentaObject) {
                
                    this.material = new THREE.LineBasicMaterial( {
	                    color: new THREE.Color(augmentaObject.color),
	                    linewidth: 10
                    } );

                    this.points = [];
                                   
                    // bb orientation
                    let theta = augmentaObject.boundingRect.rotation * 2 * Math.PI /360; // in rad
                    let s = Math.sin(theta);
                    let c = Math.cos(theta);
                    
                    // bb center
                    let x = (augmentaObject.boundingRect.x - 0.5) * windowHalfX;
                    let y = - (augmentaObject.boundingRect.y - 0.5) * windowHalfY;

                    // bb size
                    let w = augmentaObject.boundingRect.width * windowHalfX;
                    let h = augmentaObject.boundingRect.height * windowHalfY;
                    
                    //vertex
                    this.points.push( new THREE.Vector3( (w/2)*c - (h/2)*s + x , (w/2)*s + (h/2)*c + y ) , 0);
                    this.points.push( new THREE.Vector3( (w/2)*c + (h/2)*s + x , (w/2)*s - (h/2)*c + y ) , 0 );
                    this.points.push( new THREE.Vector3( -(w/2)*c + (h/2)*s + x , -(w/2)*s - (h/2)*c + y ) , 0 );
                    this.points.push( new THREE.Vector3( -(w/2)*c - (h/2)*s + x , -(w/2)*s + (h/2)*c + y ) , 0 );
                    this.points.push( new THREE.Vector3( (w/2)*c - (h/2)*s + x , (w/2)*s + (h/2)*c + y ) , 0 );

                    this.geometry = new THREE.BufferGeometry().setFromPoints( this.points );
                    this.line = new THREE.Line( this.geometry, this.material );

                    this.line.name = "bb" + augmentaObject.id;

                }

                init() {
                    scene.add(this.line);
                }

                update(augmentaObject) {
                    
                    // bb orientation
                    let theta = augmentaObject.boundingRect.rotation * 2 * Math.PI /360; // in rad
                    let s = Math.sin(theta);
                    let c = Math.cos(theta);

                    // bb center
                    let x = (augmentaObject.boundingRect.x - 0.5) * windowHalfX;
                    let y = - (augmentaObject.boundingRect.y - 0.5) * windowHalfY;

                    // bb size
                    let w = augmentaObject.boundingRect.width * windowHalfX;
                    let h = augmentaObject.boundingRect.height * windowHalfY;

                    
                    this.points[0] = new THREE.Vector3( (w/2)*c - (h/2)*s + x , (w/2)*s + (h/2)*c + y , 0 );
                    this.points[1] = new THREE.Vector3( (w/2)*c + (h/2)*s + x , (w/2)*s - (h/2)*c + y , 0 );
                    this.points[2] = new THREE.Vector3( -(w/2)*c + (h/2)*s + x , -(w/2)*s - (h/2)*c + y , 0 );
                    this.points[3] = new THREE.Vector3( -(w/2)*c - (h/2)*s + x , -(w/2)*s + (h/2)*c + y , 0 );
                    this.points[4] = new THREE.Vector3( (w/2)*c - (h/2)*s + x , (w/2)*s + (h/2)*c + y , 0 );

                    this.geometry = new THREE.BufferGeometry().setFromPoints( this.points );        
                    this.line.geometry = this.geometry; 
                        
                }

            }

            // dictionary containing bounding boxes indexed by augmenta objects' id
            let boundingBoxes = {};

            /////// FOR DISPLAY PREDATOR MODE ///////

            function initPredator(augmentaObject) {

                var geometry = new THREE.SphereGeometry( 4 );
                var material = new THREE.MeshBasicMaterial( { color: augmentaObject.color } );
                var sphere = new THREE.Mesh( geometry, material );

                sphere.name = "predator" + augmentaObject.id;

                scene.add( sphere );
                            
                predators[augmentaObject.id] = sphere;
            }

            function updatePredator(augmentaObject) {

                let x = (augmentaObject.boundingRect.x - 0.5) * windowHalfX;
                let y = - (augmentaObject.boundingRect.y - 0.5) * windowHalfY;
                predators[augmentaObject.id].position.set( x , y , 0 );

            }

            function removePredator(augmentaObject) {

                var selectedObject = scene.getObjectByName("predator" + augmentaObject.id);
                scene.remove( selectedObject );

                delete predators[augmentaObject.id];

            }

            // Dictionary containing objects representing augmenta object indexed by their id
            let predators = {};

			////// 

			let container, stats;
			let camera, scene, renderer;
			let mouseX = 1000, mouseY = 1000;

			let windowHalfX = window.innerWidth / 2;
			let windowHalfY = window.innerHeight / 2;

            let fuWidth, fuHeight;
            let fuOffsetX = 0, fuOffsetY = 0;
			let useFusionPresets = false;
            let manualWidth = window.innerWidth, manualHeight = window.innerHeight;
            let manualOffsetX = 0, manualOffsetY = 0;
            let manualMode = false;   

			const BOUNDS = 800, BOUNDS_HALF = BOUNDS / 2;

			let last = performance.now();

			let gpuCompute;
			let velocityVariable;
			let positionVariable;
			let positionUniforms;
			let velocityUniforms;
			let birdUniforms;

			//websocket address
            let ip = '127.0.0.1';
			let port = 8080; // websocket port
			let websocketurl = 'ws://'+ip+':'+port; //Set the websocket server URL
			let socket;
            let isConnected = false; // to know if the connection was successfull

            //display mode
            let mode = "Oldest Object";
            let debugMode = false;
            let displayPredators = false;

            //to make sure it doesn't update an object if it is being added
            let lock = false;

			init();
			animate();

			function init() {

				container = document.createElement( 'div' );
				document.body.appendChild( container );

				camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 3000 );
				camera.position.z = 350;

				scene = new THREE.Scene();
				// scene.background = new THREE.Color( 0xffffff );
				scene.background = new THREE.Color( 0x111111 );
				scene.fog = new THREE.Fog( 0xffffff, 100, 1000 );

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				container.appendChild( renderer.domElement );

				initComputeRenderer();

                ////// AUGMENTA MANAGER //////

                // define functions 
                        
                //get status element
	            var connstatus = document.getElementById("connectionstatus");

	            //get info div element
	            var infodiv = document.getElementById("info");


                ///// AUGMENTA EVENTS FUNCTIONS' DEFINITION /////

                let objectUpdated = (augmentaObject) => 
                {
                    if (mode == "All Objects") {
                        
                        // To scare birds
                        mouseX = (augmentaObject.boundingRect.x - 0.5) * windowHalfX;
                        mouseY = - (augmentaObject.boundingRect.y - 0.5) * windowHalfY;
                        
                        if (displayPredators) {
                            if (predators[augmentaObject.id] !== undefined) {
                                updatePredator(augmentaObject);
                            } else {
                                initPredator(augmentaObject);
                            }
                        }

                        if(debugMode && boundingBoxes[augmentaObject.id] !== undefined) {
                            boundingBoxes[augmentaObject.id].update(augmentaObject);
                        }

                    } else if (mode == "Newest Object" && augmentaObject.id == augmentaManager.newestObject.id ) {

                        mouseX = (augmentaObject.boundingRect.x - 0.5) * windowHalfX;
                        mouseY = - (augmentaObject.boundingRect.y - 0.5) * windowHalfY;

                        if (displayPredators) {
                            if (predators[augmentaObject.id] !== undefined) {
                                updatePredator(augmentaObject);
                            } else {
                                initPredator(augmentaObject);
                            }
                        }

                        if(debugMode) {
                            if (boundingBoxes[augmentaObject.id] !== undefined) {
                                boundingBoxes[augmentaObject.id].update(augmentaObject);
                            } else {
								boundingBoxes[augmentaObject.id] = new BoundingBoxDebug(augmentaObject);
                            	boundingBoxes[augmentaObject.id].init();
                            }
                        }

                    } else if (mode == "Oldest Object" && augmentaObject.id == augmentaManager.oldestObject.id ) {

                        mouseX = (augmentaObject.boundingRect.x - 0.5) * windowHalfX;
                        mouseY = - (augmentaObject.boundingRect.y - 0.5) * windowHalfY;

                        if (displayPredators) {
                            if (predators[augmentaObject.id] !== undefined) {
                                updatePredator(augmentaObject);
                            } else {
                                initPredator(augmentaObject);
                            }
                        }

                        if(debugMode) {
                            if (boundingBoxes[augmentaObject.id] !== undefined) {
                                boundingBoxes[augmentaObject.id].update(augmentaObject);
                            } else {
								boundingBoxes[augmentaObject.id] = new BoundingBoxDebug(augmentaObject);
                            	boundingBoxes[augmentaObject.id].init();
                            }
                        }

                    }
                }
                
                let objectEntered = (augmentaObject) => 
                {
                    let id = augmentaObject.id;

                    if (mode == "All Objects") {

                        if (debugMode) {
                            boundingBoxes[id] = new BoundingBoxDebug(augmentaObject);
                            boundingBoxes[id].init();
                        }

                        if (displayPredators) {
                            initPredator(augmentaObject);
                        }

                    } else if (mode == "Newest Object" && id == augmentaManager.newestObject.id ) {

                        if (debugMode) {

                            // Delete the old newest object
                            for (var key in boundingBoxes) { // key is the id, should be only one key in this case
                                var selectedObject = scene.getObjectByName("bb" + key);
                                scene.remove( selectedObject );
                                delete boundingBoxes[key];   
                            }

                            // add the new newest object 
                            boundingBoxes[id] = new BoundingBoxDebug(augmentaObject);
                            boundingBoxes[id].init();

                        }

                        if (displayPredators) {
                            
                            for (var key in predators) {
                                removePredator(augmentaManager.augmentaObjects[key]);
                            }

                            initPredator(augmentaObject);
                        }

                    } else if (mode == "Oldest Object" && id == augmentaManager.oldestObject.id ) {

                        if (debugMode) {
                            boundingBoxes[id] = new BoundingBoxDebug(augmentaObject);
                            boundingBoxes[id].init();
                        }

                        if (displayPredators) {
                            initPredator(augmentaObject);
                        }

                    }
                                    
                }

                let objectWillLeave = (augmentaObject) => 
                {

                    let id = augmentaObject.id;

                    if (mode == "All Objects") {

                        if (debugMode) { 

                            var selectedObject = scene.getObjectByName("bb" + id);
                            scene.remove( selectedObject );
                            delete boundingBoxes[augmentaObject.id];
                        }
                                          
                        if (displayPredators) {
                            removePredator(augmentaObject);
                        }

                    } else if (mode == "Newest Object" && id == augmentaManager.newestObject.id ) {

                        if (debugMode) {

                            // Delete 
                            var selectedObject = scene.getObjectByName("bb" + id);
                            scene.remove( selectedObject );
                            delete boundingBoxes[augmentaObject.id];

                            // Add the new newest object
                            if (augmentaManager.augmentaScene.objCount !== 0) {
                                boundingBoxes[augmentaManager.newestObject.id] = new BoundingBoxDebug(augmentaManager.newestObject);
                                boundingBoxes[augmentaManager.newestObject.id].init();
                            }
                        }

                        if (displayPredators) {
                            removePredator(augmentaObject);
                            if (augmentaManager.augmentaScene.objCount !== 0) {
                                initPredator(augmentaManager.newestObject.id);
                            }
                        }

                    } else if (mode == "Oldest Object" && id == augmentaManager.oldestObject.id ) {

                        if (debugMode) {

                            // Delete 
                            var selectedObject = scene.getObjectByName("bb" + id);
                            scene.remove( selectedObject );
                            delete boundingBoxes[augmentaObject.id];

                            // Add the new oldest object
                            boundingBoxes[augmentaManager.oldestObject.id] = new BoundingBoxDebug(augmentaManager.oldestObject);
                            boundingBoxes[augmentaManager.oldestObject.id].init();
                        }

                        if (displayPredators) {
                            removePredator(augmentaObject);
                            if (augmentaManager.augmentaScene.objCount !== 0) {
                                initPredator(augmentaManager.newestObject.id);
                            }
                        }

                    }
                }

                let websocketOpened = () => {

                    // update status
                    connstatus.innerHTML = "Connected!";
                    isConnected = true;
                    
                    // update object if debugMode is enables 
                    if (debugMode) {
                        debugModeChanger();
                    }
                    
                }
            
                let websocketClosed = () => {
                    
                    // update status
                    connstatus.innerHTML = "Disconnected";
                    isConnected = false;

                    // clean scene if debug is enabled
                    if(debugMode) {
                        for (var id in boundingBoxes) {
                            var selectedObject = scene.getObjectByName("bb" + id);
                            scene.remove( selectedObject );
                            delete boundingBoxes[id];
                        }
                    }

                    // clean scene if display predators is enabled
                    if(displayPredators) {
                        for (var id in predators) {
                            removePredator(augmentaManager.augmentaObjects[id]);
                        }
                    }
                }

				let fusionUpdated = () => {
					if(useFusionPresets) {
						if(fuWidth != augmentaManager.fusion.videoOutInPixels.x || fuHeight != augmentaManager.fusion.videoOutInPixels.y || 
							fuOffsetX != augmentaManager.fusion.offsetX || fuOffsetY != augmentaManager.fusion.offsetY) {
							
							// Update Size
							fuWidth = augmentaManager.fusion.videoOutInPixels.x;
                            fuHeight = augmentaManager.fusion.videoOutInPixels.y;
                        
                            // Update Offset
                            fuOffsetX = augmentaManager.fusion.offsetX;
                            fuOffsetY = augmentaManager.fusion.offsetY;

							windowHalfX = fuWidth / 2;
				            windowHalfY = fuHeight / 2;

				            camera.aspect = fuWidth / fuHeight;
				            camera.updateProjectionMatrix();

                            // Set offset and size
			                renderer.setViewport(fuOffsetX, fuOffsetY, fuWidth, fuHeight);

							console.log("fusion updated!")
						}
					}
				}
			
                //Initialize augmenta manager 
                let augmentaManager = new AugmentaManager();

                //Set functions
                augmentaManager.setObjectUpdated(objectUpdated);
                augmentaManager.setObjectEntered(objectEntered);
                augmentaManager.setObjectWillLeave(objectWillLeave);
                augmentaManager.setWebsocketOpened(websocketOpened);
                augmentaManager.setWebsocketClosed(websocketClosed);
				augmentaManager.setFusionUpdated(fusionUpdated);
            
                //Start websocket connection
                augmentaManager.startAugmentaWebsocket();

                /////// Event listeners ///////

				window.addEventListener( 'resize', onWindowResize );
                container.style.touchAction = 'none';
				//container.addEventListener( 'pointermove', onPointerMove );

                /////// Controllers and UI ///////

				const gui = new GUI();

				const effectFolder = gui.addFolder('Effect');

				const effectController = {
					separation: 20.0,
					alignment: 20.0,
					cohesion: 20.0,
					freedom: 0.75,
				};

				const valuesChanger = function () {

					velocityUniforms[ 'separationDistance' ].value = effectController.separation;
					velocityUniforms[ 'alignmentDistance' ].value = effectController.alignment;
					velocityUniforms[ 'cohesionDistance' ].value = effectController.cohesion;
					velocityUniforms[ 'freedomFactor' ].value = effectController.freedom;

				};

				valuesChanger();

				effectFolder.add( effectController, 'separation', 0.0, 100.0, 1.0 ).onChange( valuesChanger );
				effectFolder.add( effectController, 'alignment', 0.0, 100, 0.001 ).onChange( valuesChanger );
				effectFolder.add( effectController, 'cohesion', 0.0, 100, 0.025 ).onChange( valuesChanger );
				
                /////// AUGMENTA CONTROLLER ///////

				const augmentaFolder = gui.addFolder('Augmenta Manager');

                const augmentaController = {
					port: 8080,
					ip: '127.0.0.1',
					useSecureConnection: false,
                    displayMode: "Oldest Object",
                    enableDebugMode: false,
                    displayPredators: false
				};

				
                // Change websocket address
                const auChanger = function () {
					port = augmentaController.port;
					ip = augmentaController.ip;
					var useSecureConnection = augmentaController.useSecureConnection;

                    augmentaManager.changePort(port);
                    augmentaManager.changeIP(ip); 
					augmentaManager.useSecureConnection = useSecureConnection;

				}

                // To change display mode (all objects, newest object, oldest object)
                const displayChanger = function () 
                {        
                    mode = augmentaController.displayMode;

                    if (mode == "All Objects") {

                        if (debugMode) {

                            for (var id in boundingBoxes) {
                                var selectedObject = scene.getObjectByName("bb" + id);
                                scene.remove( selectedObject );  
                                delete boundingBoxes[id];
                            }

                            for (var id in augmentaManager.augmentaObjects) {
                                boundingBoxes[id] = new BoundingBoxDebug(augmentaManager.augmentaObjects[id]);
                                boundingBoxes[id].init();
                            }

                        }

                        if (displayPredators) {

                            for (var id in predators) {
                                removePredator(augmentaManager.augmentaObjects[id]);
                            }

                            for (var id in augmentaManager.augmentaObjects) {
                                initPredator(augmentaManager.augmentaObjects[id]);
                            }

                        }

                    } else if (mode == "Oldest Object") {

                        if (debugMode) {

                            for (var id in boundingBoxes) {
                                var selectedObject = scene.getObjectByName("bb" + id);
                                scene.remove( selectedObject );  
                                delete boundingBoxes[id];
                            }
                            
                            let object = augmentaManager.oldestObject;
                            boundingBoxes[object.id] = new BoundingBoxDebug(object);
                            boundingBoxes[object.id].init();

                        }

                        if (displayPredators) {

                            for (var id in predators) {
                                removePredator(augmentaManager.augmentaObjects[id]);
                            }

                            initPredator(augmentaManager.oldestObject);
           
                        }

                    } else if (mode == "Newest Object") {

                        if (debugMode) {

                           for (var id in boundingBoxes) {
                                var selectedObject = scene.getObjectByName("bb" + id);
                                scene.remove( selectedObject ); 
                                delete boundingBoxes[id];
                            }
                            
                            let object = augmentaManager.newestObject;
                            boundingBoxes[object.id] = new BoundingBoxDebug(object);
                            boundingBoxes[object.id].init();

                        }

                        if (displayPredators) {

                            for (var id in predators) {
                                removePredator(augmentaManager.augmentaObjects[id]);
                            }

                            initPredator(augmentaManager.newestObject);
                        }
                    }
                }


                //  Enable or disable display predators mode
                const predatorChanger = function () {

                    displayPredators = augmentaController.displayPredators;

                    if (displayPredators) {

                        if (mode == "All Objects") {

                            for (var id in augmentaManager.augmentaObjects) {
                                initPredator(augmentaManager.augmentaObjects[id]);
                            }

                        } else if (mode == "Newest Object") {
                            
                            initPredator(augmentaManager.newestObject);
                            
                        } else if (mode == "Oldest Object") {

                            initPredator(augmentaManager.oldestObject);

                        }

                    } else {                      
                        for (var id in predators) {
                            removePredator(augmentaManager.augmentaObjects[id]);
                        }                       
                    }

                }

                // Enable or disable debug mode
                const debugModeChanger = function () 
                {
                    debugMode = augmentaController.enableDebugMode;
                    
                    if(debugMode) {

                        if (mode == "All Objects") {

                            for (var id in augmentaManager.augmentaObjects) {
                                boundingBoxes[id] = new BoundingBoxDebug(augmentaManager.augmentaObjects[id]);
                                boundingBoxes[id].init();
                            }

                        } else if (mode == "Oldest Object") {

                            let object = augmentaManager.oldestObject;
                            boundingBoxes[object.id] = new BoundingBoxDebug(object);
                            boundingBoxes[object.id].init();

                        } else if (mode == "Newest Object") {

                            let object = augmentaManager.newestObject;
                            boundingBoxes[object.id] = new BoundingBoxDebug(object);
                            boundingBoxes[object.id].init();

                        }

                    } else {
                        
                        // remove all bounding boxes' 3D objects from the scene
                        for (var id in boundingBoxes) {
                            var selectedObject = scene.getObjectByName("bb" + id);
                            scene.remove( selectedObject );
                            delete boundingBoxes[id];
                        }
                    }
                }

				augmentaFolder.add( augmentaController, 'ip', '127.0.0.1').onChange( auChanger );
				augmentaFolder.add( augmentaController, 'port', 8080).onChange( auChanger );
				augmentaFolder.add( augmentaController, 'useSecureConnection', false).onChange( auChanger );
                augmentaFolder.add( augmentaController, 'displayMode', ["Oldest Object", "Newest Object", "All Objects"]).onChange( displayChanger );
                augmentaFolder.add( augmentaController, 'displayPredators', false).onChange( predatorChanger );
                augmentaFolder.add( augmentaController, 'enableDebugMode', false).onChange( debugModeChanger );


				//////// FUSION OUTPUT SIZE ///////// 

				const fusionOutputFolder = gui.addFolder('Fusion output');

				const fusionOutputController = {
					fusionPresets: false,
					offsetX: 0,
					offsetY: 0,
					autoComputeOffset: false
				};

                // Enable or disable fusion presets for output video
                const fusionPresets = function () {

					if (isConnected) {

						useFusionPresets = fusionOutputController.fusionPresets;

						if (useFusionPresets) {

							// Update Size
							fuWidth = augmentaManager.fusion.videoOutInPixels.x;
							fuHeight = augmentaManager.fusion.videoOutInPixels.y;
						
							// Update Offset
							fuOffsetX = fusionOutputController.offsetX;
							fuOffsetY = fusionOutputController.offsetY;

							windowHalfX = fuWidth / 2;
							windowHalfY = fuHeight / 2;

							camera.aspect = fuWidth / fuHeight;
							camera.updateProjectionMatrix();

							// Set offset and size
							renderer.setViewport(fuOffsetX, fuOffsetY, fuWidth, fuHeight);

						} else {

							windowHalfX = window.innerWidth / 2;
							windowHalfY = window.innerHeight / 2;

							camera.aspect = window.innerWidth / window.innerHeight;
							camera.updateProjectionMatrix();

							renderer.setSize( window.innerWidth, window.innerHeight );
						}
					}
				}

				const changeFusionOffset = function() {

					// Update Offset
					fuOffsetX = fusionOutputController.offsetX;
					fuOffsetY = fusionOutputController.offsetY;

					if (useFusionPresets) {

							// Update Size
							fuWidth = augmentaManager.fusion.videoOutInPixels.x;
							fuHeight = augmentaManager.fusion.videoOutInPixels.y;

							
							augmentaManager.fusion.offsetX = fuOffsetX;
							augmentaManager.fusion.offsetY = fuOffsetY;

							windowHalfX = fuWidth / 2;
							windowHalfY = fuHeight / 2;

							camera.aspect = fuWidth / fuHeight;
							camera.updateProjectionMatrix();

							// Set offset and size
							renderer.setViewport(fuOffsetX, fuOffsetY, fuWidth, fuHeight);
					}
				} 

				const computeOffset = function() {
					
					fusionOutputController.offsetX = (innerWidth - augmentaManager.fusion.videoOutInPixels.x) / 2;
					fusionOutputController.offsetY = (innerHeight - augmentaManager.fusion.videoOutInPixels.y) / 2;
					gui.updateDisplay()

					// Update Offset
					fuOffsetX = fusionOutputController.offsetX;
					fuOffsetY = fusionOutputController.offsetY;

					if (fusionOutputController.autoComputeOffset) {
						changeFusionOffset();
					}
				}

				fusionOutputFolder.add( fusionOutputController, 'fusionPresets', false).onChange( fusionPresets );
				fusionOutputFolder.add( fusionOutputController, 'autoComputeOffset', false).onChange( computeOffset );
				fusionOutputFolder.add( fusionOutputController, 'offsetX', 0).onChange( changeFusionOffset );
				fusionOutputFolder.add( fusionOutputController, 'offsetY', 0).onChange( changeFusionOffset );

                //////// CUSTOM OUTPUT SIZE ///////// 

                const customOutputFolder = gui.addFolder('Custom output');

				const customOutputController = {
                    manualOutput: false,
					offsetX: 0,
					offsetY: 0,
					width: window.innerWidth,
					height: window.innerHeight,
				};

                const manualModeChanger = function () 
                {
                    manualMode = customOutputController.manualOutput;
                    if (manualMode) {
                        renderer.setViewport(manualOffsetX,window.innerHeight - manualOffsetY - manualHeight, manualWidth, manualHeight);
                    } else if (isConnected) {
                        fusionPresets();
                    } else {

            			windowHalfX = window.innerWidth / 2;
				        windowHalfY = window.innerHeight / 2;

				        camera.aspect = window.innerWidth / window.innerHeight;
				        camera.updateProjectionMatrix();

				        renderer.setSize( window.innerWidth, window.innerHeight );
                    }
                }

                const outputChanger = function () 
                {                    
                    manualOffsetX = customOutputController.offsetX;
                    manualOffsetY = customOutputController.offsetY;
                    
                    manualWidth = customOutputController.width;
                    manualHeight = customOutputController.height;

                    if (manualMode) {
                        // Set offset
			            renderer.setViewport(manualOffsetX,window.innerHeight - manualOffsetY - manualHeight, manualWidth, manualHeight);
                    }
                }

                customOutputFolder.add( customOutputController, 'manualOutput', false).onChange( manualModeChanger );
                customOutputFolder.add( customOutputController, 'offsetX', 0).onChange( outputChanger );
                customOutputFolder.add( customOutputController, 'offsetY', 0).onChange( outputChanger );
                customOutputFolder.add( customOutputController, 'width', 0).onChange( outputChanger );
                customOutputFolder.add( customOutputController, 'height', 0).onChange( outputChanger );

				gui.close();

				initBirds();
			}

			function initComputeRenderer() {

				gpuCompute = new GPUComputationRenderer( WIDTH, WIDTH, renderer );

				if ( isSafari() ) {

					gpuCompute.setDataType( THREE.HalfFloatType );

				}

				const dtPosition = gpuCompute.createTexture();
				const dtVelocity = gpuCompute.createTexture();
				fillPositionTexture( dtPosition );
				fillVelocityTexture( dtVelocity );

				velocityVariable = gpuCompute.addVariable( 'textureVelocity', document.getElementById( 'fragmentShaderVelocity' ).textContent, dtVelocity );
				positionVariable = gpuCompute.addVariable( 'texturePosition', document.getElementById( 'fragmentShaderPosition' ).textContent, dtPosition );

				gpuCompute.setVariableDependencies( velocityVariable, [ positionVariable, velocityVariable ] );
				gpuCompute.setVariableDependencies( positionVariable, [ positionVariable, velocityVariable ] );

				positionUniforms = positionVariable.material.uniforms;
				velocityUniforms = velocityVariable.material.uniforms;

				positionUniforms[ 'time' ] = { value: 0.0 };
				positionUniforms[ 'delta' ] = { value: 0.0 };
				velocityUniforms[ 'time' ] = { value: 1.0 };
				velocityUniforms[ 'delta' ] = { value: 0.0 };
				velocityUniforms[ 'testing' ] = { value: 1.0 };
				velocityUniforms[ 'separationDistance' ] = { value: 1.0 };
				velocityUniforms[ 'alignmentDistance' ] = { value: 1.0 };
				velocityUniforms[ 'cohesionDistance' ] = { value: 1.0 };
				velocityUniforms[ 'freedomFactor' ] = { value: 1.0 };
				velocityUniforms[ 'predator' ] = { value: new THREE.Vector3() };
				velocityVariable.material.defines.BOUNDS = BOUNDS.toFixed( 2 );

				velocityVariable.wrapS = THREE.RepeatWrapping;
				velocityVariable.wrapT = THREE.RepeatWrapping;
				positionVariable.wrapS = THREE.RepeatWrapping;
				positionVariable.wrapT = THREE.RepeatWrapping;

				const error = gpuCompute.init();

				if ( error !== null ) {

					console.error( error );

				}

			}

			function isSafari() {

				return !! navigator.userAgent.match( /Safari/i ) && ! navigator.userAgent.match( /Chrome/i );

			}

			function initBirds() {

				const geometry = new BirdGeometry();

				// For Vertex and Fragment
				birdUniforms = {
					'color': { value: new THREE.Color( 0xff2200 ) },
					'texturePosition': { value: null },
					'textureVelocity': { value: null },
					'time': { value: 1.0 },
					'delta': { value: 0.0 }
				};

				// THREE.ShaderMaterial
				const material = new THREE.ShaderMaterial( {
					uniforms: birdUniforms,
					vertexShader: document.getElementById( 'birdVS' ).textContent,
					fragmentShader: document.getElementById( 'birdFS' ).textContent,
					side: THREE.DoubleSide

				} );

				const birdMesh = new THREE.Mesh( geometry, material );
				birdMesh.rotation.y = Math.PI / 2;
				birdMesh.matrixAutoUpdate = false;
				birdMesh.updateMatrix();

				scene.add( birdMesh );

			}

			function fillPositionTexture( texture ) {

				const theArray = texture.image.data;

				for ( let k = 0, kl = theArray.length; k < kl; k += 4 ) {

					const x = Math.random() * BOUNDS - BOUNDS_HALF;
					const y = Math.random() * BOUNDS - BOUNDS_HALF;
					const z = Math.random() * BOUNDS - BOUNDS_HALF;

					theArray[ k + 0 ] = x;
					theArray[ k + 1 ] = y;
					theArray[ k + 2 ] = z;
					theArray[ k + 3 ] = 1;

				}

			}

			function fillVelocityTexture( texture ) {

				const theArray = texture.image.data;

				for ( let k = 0, kl = theArray.length; k < kl; k += 4 ) {

					const x = Math.random() - 0.5;
					const y = Math.random() - 0.5;
					const z = Math.random() - 0.5;

					theArray[ k + 0 ] = x * 10;
					theArray[ k + 1 ] = y * 10;
					theArray[ k + 2 ] = z * 10;
					theArray[ k + 3 ] = 1;

				}

			}

			function onWindowResize() {

                if (!useFusionPresets && !manualMode) 
                {
				    windowHalfX = window.innerWidth / 2;
				    windowHalfY = window.innerHeight / 2;

				    camera.aspect = window.innerWidth / window.innerHeight;
				    camera.updateProjectionMatrix();

				    renderer.setSize( window.innerWidth, window.innerHeight );

                } else if (useFusionPresets && autoComputeOffset) {

					computeOffset();
					console.log("resized")

               }

			}

            function onPointerMove( event ) {
                console.log(event.clientX + ',' + event.clientY);
            }

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				const now = performance.now();
				let delta = ( now - last ) / 1000;

				if ( delta > 1 ) delta = 1; // safety cap on large deltas
				last = now;

				positionUniforms[ 'time' ].value = now;
				positionUniforms[ 'delta' ].value = delta;
				velocityUniforms[ 'time' ].value = now;
				velocityUniforms[ 'delta' ].value = delta;
				birdUniforms[ 'time' ].value = now;
				birdUniforms[ 'delta' ].value = delta;

				velocityUniforms[ 'predator' ].value.set( 0.5 * mouseX / windowHalfX, - 0.5 * mouseY / windowHalfY, 0 );

				//mouseX = 10000;
				//mouseY = 10000;

				gpuCompute.compute();

				birdUniforms[ 'texturePosition' ].value = gpuCompute.getCurrentRenderTarget( positionVariable ).texture;
				birdUniforms[ 'textureVelocity' ].value = gpuCompute.getCurrentRenderTarget( velocityVariable ).texture;

				renderer.render( scene, camera );

			}

		</script>
	</body>
</html>
